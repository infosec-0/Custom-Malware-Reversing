#!/bin/bash

# User interface header

  ▄████  ▒█████   ▄▄▄     ▄▄▄█████▓▄▄▄█████▓▄▄▄█████▓
 ██▒ ▀█▒▒██▒  ██▒▒████▄   ▓  ██▒ ▓▒▓  ██▒ ▓▒▓  ██▒ ▓▒
▒██░▄▄▄░▒██░  ██▒▒██  ▀█▄ ▒ ▓██░ ▒░▒ ▓██░ ▒░▒ ▓██░ ▒░
░▓█  ██▓▒██   ██░░██▄▄▄▄██░ ▓██▓ ░ ░ ▓██▓ ░ ░ ▓██▓ ░ 
░▒▓███▀▒░ ████▓▒░ ▓█   ▓██▒ ▒██▒ ░   ▒██▒ ░   ▒██▒ ░ 
 ░▒   ▒ ░ ▒░▒░▒░  ▒▒   ▓▒█░ ▒ ░░     ▒ ░░     ▒ ░░   
  ░   ░   ░ ▒ ▒░   ▒   ▒▒ ░   ░        ░        ░    
░ ░   ░ ░ ░ ░ ▒    ░   ▒    ░        ░        ░      
      ░     ░ ░        ░  ░                          
                                                     

print("\n****************************************************************")
print("\n*  License : MIT                                               *")
print("\n*  Copyright (c) 2022 RR Lubin                              	  *")
print("\n*  https://www.debug.tips                                  		*")
print("\n*                           																	  *")
print("\n****************************************************************")

# You are using reconGoat -- Lubin's Bourne Again Shell (Bash) scripting 
# for reconnaissance automation (via exposing domains)


# First stage in automation looks for subdomains
# ./recongoat.sh leverages chaos' Project-Discovery -- lists of domains [and subdomains] 
# enumurated, updated and maintained (i.e. for bug bounties)
# suggested usecase: auto recon via brute-forcing subdomains = loud

# ./recongoatlvl2.sh = using open-source intelligence (OSINT) tools like Amass, Subfinder, 
# and Assetfinder via reconGoatlvl2 -- advised when scapegoat isn't on choas' Project-Discovery
# Scapegoat = Target
# suggested usecase: hunting on a public scope = quiet


domain=$1
domain_enum(){
mkdir -p $domain $domain/subdomains $domain/intel $domain/nuclei
# 'mkdir -p' command will create sub-directories of a directory ('$domains'), It will first create 
# the parent directory, if it doesn't exist

python3 /home/scripts_tools/Desktop/Sublist3r.py -d $domain -o $domain/subdomains/sublister.txt
# call 'python3' to begin subdomain enumeration via sublister.py
# use '-d $domain' to specify domain: debug.tips
# push the specified domain output to: sublister.txt [with '-o $domain/subdomains/sublister.txt']
  
subfinder -d $domain -v -o $domain/subdomains/subfinder.txt
# call subfinder; specify domain with '-d $domain', verbose with 'v', and switch '-o' for output to: 
# 'subfinder.txt' then place it in the subdomains folder

assetfinder -subs-only $domain -v | tee $domain/subdomains/assetfinder.txt
# call assetfinder; the switch '-subs-only' will only fetch the subdomains of debug.tips, No associated 
# domains will be retrieved.
# '$domain' will specify domain; again 'v' for verbose then push to: assetfinder.txt

cat $domain/subdomains/*.txt > $domain/subdomains/all.txt
# duplicate + 'www.' removal: Script cleanup
# compile all three sublister, subfinder, and assetfinder files into 'all.txt' file

mv $domain/subdomains/all.txt /home/scripts_tools/Desktop/
# duplicate + 'www.' removal: Script cleanup
# move all.txt out from subdomains' folder to desktop

sort /home/scripts_tools/Desktop/all.txt | uniq -u /home/scripts_tools/Desktop/all.txt > output.txt
# duplicate + 'www.' removal: Script cleanup
# use 'sort' to sort all.txt, arranging the records in a particular order.
# use 'uniq' to remove duplicates or only display non-repeated lines
# save the newly sorted all.txt to: output.txt [to desktop]

cat /home/scripts_tools/Desktop/output.txt | sed 's/www.//' > nowww.txt
# duplicate + 'www.' removal: Script cleanup
# 'concatenate' output.txt to read from the file and display its content,
# and use [stream editor] 'sed' to find and remove any matches for 'www.'
# format will appear as: subdomain.top-level-domain.com
# save the newly edited output.txt to: nowww.txt [to desktop]  

sort /home/scripts_tools/Desktop/nowww.txt | uniq > domains.txt
# duplicate + 'www.' removal: Script cleanup
# sort 'nowww.txt' for duplicates, remove or display only non-duplicates
# save the newly sorted domains.txt to: domains.txt [to desktop]

mv /home/scripts_tools/Desktop/domains.txt $domain/subdomains/
# duplicate + 'www.' removal: Script cleanup
# move 'domains.txt' back into subdomains' folder

rm /home/scripts_tools/Desktop/all.txt output.txt nowww.txt
# duplicate + 'www.' removal: Script cleanup
# remove 'all.txt' + 'output.txt' + 'nowww.txt'
}
domain_enum


httpscan(){
httpx -l /home/scripts_tools/Desktop/debug.tips/subdomains/domains.txt -o httpx.txt
# Next see what is live and active: push domains.txt to httpx client
# use httpx '-l' command to list 'active' subdomains then specify the location 
# and save the newly edited domains.txt to: httpx.txt

mv /home/scripts_tools/Desktop/httpx.txt $domain/intel
# once httpx's scan is complete move 'httpx.txt' to Desktop
# then push to subdomains' intelligence folder
}
httpscan


scanner(){
cat $domain/intel/httpx.txt | nuclei -t /home/scripts_tools/nuclei-templates/ -o $domain/intel/nuclei/httpxintel.txt
# 'concatenate' httpx.txt and push to nuclei for template scanning via 'nuclei -t'
# output the positive hits that results from scanning [ALL] nuclei's templates
# (there are a ton of constantly updated templates in the nuclei github repository)
# alternatively you may specify CVEs or vulnerabilities in place of nuclei templates
# save the newly edited 'httpx.txt' within domain's intelligence folder's Nuclei: httpxintel.txt 
}
scanner


fuzz(){
ffuf -u https://debug.tips/FUZZ -recursion -s -w /home/scripts_tools/Desktop/filebuster/wordlists/thorough.txt -o $domain/intel/fuzzed.json
# call fuzz faster you fool 'ffuf' (fast web fuzzer written in Go)
# fuzz scapegoat: debug.tips
# the '-recursion' switch tells ffuf that if it enounters a directory it should 
# start another scan within that directory and so on until no more results are found
# use '-s' (silent mode) to avoid printing additional information
# use '-w' for word list; currently via ffuf's 'thorough.txt' word list 
# save the newly fuzzed output into our domain's intelligence folder as: fuzz.json
}
fuzz


oneforalltakeover(){
cp $domain/intel/httpx.txt /home/scripts_tools/Desktop/OneForAll/
# copy httpx.txt from domain's intelligence folder to OneForAll on Desktop
# OneForAll = Subdomain collection tools, an indispensable part of reconnaissance

python3 /home/scripts_tools/Desktop/OneForAll/oneforall.py --targets /home/scripts_tools/Desktop/OneForAll/httpx.txt --takeover True run
# to run oneforalltakeover we need to use python3; to call oneforall.py
# use '--targets' for multiple domains
# point the takeovers to httpx.txt [enumurated active subdomains]
# specifing 'run' allows oneforalltakeover to run through httpx.txt and output 
# everything in a few csv files 

mv /home/scripts_tools/Desktop/OneForAll/results/*.csv $domain/intel/
}
# information will be stored in one central location
# use 'move' to push the CSV files into domain's intelligence folder
oneforalltakeover


takeover(){
./takeover.sh
# ultimately one pass is for kids!! [baby goats] 
# do a second takeover pass with another subdomain takeover tool called 'takeover.sh'
# once running, select httpx.txt [enumurated active subdomains] and specify
# file location: /home/scripts_tools/Desktop/debug.tips/intel/httpx.txt
}
takeover

 
# You have successfully perfomered subdomain reconnaissance -- script provided by Lubin 
# Script flow
# 1. Gather scapegoat's subdomains
# 2. Push subdomains for 'live' verification to Httpx (faster, more modern successor to 
# 'Requests' module: the simple, python HTTP library to send HTTP requests) 
# 3. After successful 'live'-check, push active subdomains to Nuclei for vulnerability scanning 
# 4. Scan scapegoat's subdomains: Nuclei may provide info on web technologies, any misconfigurations, and any CVEs
# 5. Collect Nuclei's results into a file (for manual investigation = Burp, Za proxy, etc.)
# 6. Use Ffuf to brute-force directories 
# 7. Collect Ffuf's results into a file (for more, manual investigation = Burp, Za proxy, etc.)
# 8. Use subdomain takeovers to .. takeover via HTTPx 'live'-check
# 9. Collect Takeover's results into a file (for even more, manual investigation = Burp, Za proxy, etc.)
